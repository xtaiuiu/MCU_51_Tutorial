C51 COMPILER V9.57.0.0   MAIN_CORRECT                                                      01/27/2026 13:25:31 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN_CORRECT
OBJECT MODULE PLACED IN .\Objects\main_correct.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE main_correct.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main_correct.lst) OBJECT(.\Objects\main_correct.obj)

line level    source

   1          #include "reg52.h"
   2          typedef unsigned int u16;
   3          typedef unsigned char u8;
   4          
   5          sbit LED1 = P2^0;
   6          sbit LED2 = P2^1;
   7          sbit BEEP = P2^5;
   8          sbit KEY  = P3^2;
   9          
  10          u16 g_beep_cnt = 0;
  11          u16 g_led1_cnt = 0;  //为LED1 统计经过了多少个100us，当该值达到5000时，LED1 闪烁并重置该值
  12          bit g_beep_ctl = 1;
  13          bit key_flag = 0;  // key 是否按下的 flag
  14          u16 g_key_cnt = 0;  // key 消抖时延计数，单位100us.
  15          
  16          
  17          //采用定时器实现，要求：只使用T0一个计时器
  18          
  19          void timer0_serv(void) interrupt 1
  20          {
  21   1              /****************************************
  22   1              *** 蜂鸣器控制
  23   1              ****************************************/
  24   1              if(1 == g_beep_ctl)
  25   1              {
  26   2                      BEEP = ~BEEP;  //每隔 100us 蜂鸣器电平翻转一次，即可发出频率为5000的音频
  27   2                      if(++g_beep_cnt > 60000)
  28   2                      {
  29   3                              BEEP = 0; // 关闭蜂鸣器
  30   3                              g_beep_ctl = 0; // 时间到，停止蜂鸣器。下次进入此中断服务程序后，BEEP相关逻辑均失效（即不再响应）
  31   3                              //TH0 = 0x3c; TL0 = 0xb0; //装入 LED1 闪烁 Timer的初值
  32   3                      }
  33   2              }
  34   1              /****************************************
  35   1              *** LED1 闪烁控制
  36   1              ****************************************/
  37   1              if(++g_led1_cnt >= 5000)
  38   1              {
  39   2                      LED1 = ~LED1;
  40   2                      g_led1_cnt = 0;
  41   2              }
  42   1              /****************************************
  43   1              *** 按键控制 LED2。 先消抖，再闪烁LED2
  44   1              ****************************************/
  45   1              if(key_flag)
  46   1              {
  47   2                      if(KEY == 0)
  48   2                      {
  49   3                              if(++g_key_cnt >= 20)
  50   3                              {
  51   4                                      LED2 = ~LED2;
  52   4                                      
  53   4                                      /*****************************************
  54   4                                      * 关键：处理完一次就清。如果不清，下次Timer溢出后（可能很快溢出，此时还按着键），LED会再翻转一次
C51 COMPILER V9.57.0.0   MAIN_CORRECT                                                      01/27/2026 13:25:31 PAGE 2   

  55   4                                      * 时间快的话会看不清楚LED的状态有没有被翻转
  56   4                                      *****************************************/
  57   4                                      g_key_cnt = 0;
  58   4                                      key_flag  = 0;   
  59   4                              }
  60   3                      }
  61   2                      else
  62   2                      {
  63   3                              g_key_cnt = 0;
  64   3                              key_flag = 0;
  65   3                      }
  66   2              }
  67   1              
  68   1              
  69   1              TH0 = 0xff; TL0 = 0x9c; //重装 Timer0 初值（Timer溢出后，不会重装初值，只会重置溢出位）
  70   1      }       
  71          
  72          void int0_serv(void) interrupt 0
  73          {
  74   1              /****************************************
  75   1              *** 按键控制 LED2, 当P3^2处的按键按下时，将按键标志置1
  76   1              *** 此处只设置标志位，不放置其他逻辑。消抖和LED2闪烁放在Timer 0的中断服务函数中
  77   1              ****************************************/
  78   1              key_flag = 1;  // 按键“疑似”被按下
  79   1      }
  80          
  81          void main(void)
  82          {
  83   1              //u8 key;
  84   1              EA = 1;
  85   1              ET0 = 1; //允许定时器中断
  86   1              EX0 = 1; //允许外部中断0中断
  87   1              IT0 = 1; //下降沿触发，避免按键长时间按下后一直触发此中断
  88   1              TMOD = 0x01;  // Timer 0 采用 16位定时器模式（方式1）
  89   1              TH0 = 0xff;
  90   1              TL0 = 0x9c;
  91   1              TR0 = 1; // Timer 0 启动
  92   1              while(1)
  93   1              {
  94   2              }
  95   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    181    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
